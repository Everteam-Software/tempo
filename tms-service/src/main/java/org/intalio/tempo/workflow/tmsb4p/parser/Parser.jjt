
options {
	JAVA_UNICODE_ESCAPE = true;
	MULTI = true;
	VISITOR = true;
	NODE_DEFAULT_VOID = true;
	STATIC = false;
	IGNORE_CASE = true;
	VISITOR_EXCEPTION = "ParseException";
}


/***************************************************************
PARSER BEGIN
***************************************************************/

PARSER_BEGIN(Parser)
package org.intalio.tempo.workflow.tmsb4p.parser;

import java.math.BigDecimal;
import java.util.List;
import java.util.ArrayList;

public class Parser {
	private final static String metachars = "tnrbf\\\"";
	private final static String chars = "\t\n\r\b\f\\\"";

    private List<String> errorList = new ArrayList<String>();
	public Node parseStream(java.io.Reader stream)
							throws ParseException {
		ReInit(stream);

		// Parse the expression, and return the 
		return Start().jjtGetChild(0);
	}

	private void addToErrorList(String errorStr) {
		errorList.add(errorStr);
	}
	
	public List<String> getErrorList() {
	   return errorList;
	}

	/**
	 * Translate all escape sequences to characters. Inspired by Rob Millar's
	 * unescape() method in rcm.util.Str from the Web Sphinx project.
	 *
	 * @param inputStr String containing escape characters.
	 * @return String with all escape sequences replaced.
	 */
	private static String replaceEscape(String inputStr) {
		int len = inputStr.length();
		int p = 0;
		int i;
		
		StringBuilder output = new StringBuilder();
		
		while ((i = inputStr.indexOf('\\', p)) != -1) {
			output.append(inputStr.substring(p, i));
			
			if (i+1 == len) break;
			
			// find metacharacter
			char metac = inputStr.charAt(i+1);

			// find the index of the metac
			int k = metachars.indexOf(metac);
			if (k == -1) {
				// didn't find the metachar, leave sequence as found.
				// This code should be unreachable if the parser
				// is functioning properly because strings containing
				// unknown escape characters should not be accepted.
				output.append('\\');
				output.append(metac);
			} else {
				// its corresponding true char
				output.append(chars.charAt(k));   
			}

			// skip over both escape character & metacharacter
			p = i + 2;
		}

		// add the end of the input string to the output
		if (p < len)
			output.append(inputStr.substring(p));
		return output.toString();
	}
}

PARSER_END(Parser)


/***************************************************************
SKIP
***************************************************************/

SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"

//| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
//| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

SPECIAL_TOKEN : /* COMMENTS */
{
 <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/***************************************************************
TOKENS
***************************************************************/

/* OPERATORS */
TOKEN:
{
	< CONCAT:   "||"  >
|	< PLUS: "+"  >
|	< MINUS:"-"  >
|	< MUL:  "*"  >
|	< DIV:  "/"  >
|	< DIV2:  "div"  >
|	< MOD:  "mod"  >
|	< GT:   ">"  >
|	< LT:   "<"  >
|	< EQ:   "=" >
|	< LE:   "<=" >
|	< GE:   ">=" >
|	< NE:   "!=" >
|	< NE2:   "<>" >
|	< AND:  "and" >
|	< OR:   "or" >
|	< NOT:  "not"  >
|	< IS_NULL:  "is null"  >
|	< IS_NOT_NULL:  "is not null"  >
|	< IN:  "in"  >
|	< NOT_IN:  "not in"  >
|	< BETWEEN:  "between"  >
|	< LIKE:  "like"  >
|	< NOT_LIKE:  "not like"  >
}


TOKEN : /* LITERALS */
{
	< NULL_LITERAL: "null">
|
	< TRUE_LITERAL: "true">
|
	< FALSE_LITERAL: "false">
|
	< INTEGER_LITERAL:
		<DECIMAL_LITERAL>
	>
|
	< #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
	< FLOATING_POINT_LITERAL:
		(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
		| "." (["0"-"9"])+ (<EXPONENT>)?
		| (["0"-"9"])+ <EXPONENT>
	>
|
	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
	< STRING_LITERAL:
		"'"
		( (~["'","\\","\n","\r"])
		| ("\\" (["n","t","b","r","f","\\","\""])?)
		)*
		"'"
	>
}

/* IDENTIFIERS 
	
	Letters before version 2.22
	< #LETTER: ["_","a"-"z","A"-"Z"] >
*/

TOKEN :
{
	< IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|<OTHER_LETTER>)* >
|
	< #LETTER:
	[
/*		"\u003A",           // : Colon*/
		"\u0041"-"\u005a",  // A - Z
		"\u0061"-"\u007a",  // a - z
		"\u00c0"-"\u00d6",  // Upper case symbols of Latin-1 Supplement
		"\u00d8"-"\u00f6",  // Lower case symbols of Latin-1 Supplement
		"\u00f8"-"\u00ff",  // More lower case symbols of Latin-1 Supplement
		"\u0100"-"\u1fff",  // Many languages (including Greek)
		"\u3040"-"\u318f",  // Hiragana, Katakana, Bopomofo, Hangul Compatibility Jamo
		"\u3300"-"\u337f",  // CJK Compatibility
		"\u3400"-"\u3d2d",  // CJK Unified Ideographs Extension A
		"\u4e00"-"\u9fff",  // CJK Unified Ideographs
		"\uf900"-"\ufaff"   // CJK Compatibility Ideographs
	]
	>	
|
	< #DIGIT: ["0"-"9"] >
|
	< #OTHER_LETTER: 
        [
		"\u005f",           // _
		"\u002E"           // . Full stop
        ]
        >
}

/***************************************************************
GRAMMAR START
***************************************************************/

ASTStart Start() #Start :
{
}
{
	Expression() <EOF> { return jjtThis; }
	|  <EOF>
	{
		return null;
	}
}

/****
	Expression with boolean result 
*/

void Expression() : {}
{
  OrExpression()
}

void OrExpression() :
{
}
{
	AndExpression()
	(
	  ( <OR> AndExpression()
		{
			jjtThis.setFunction(tokenImage[OR]);
		}
	  ) #FunNode(2)
	)*
}


void AndExpression() :
{
}
{
	EqualExpression()
	(
	  ( <AND> EqualExpression()
		{
			jjtThis.setFunction(tokenImage[AND]);
		}
	  ) #FunNode(2)
	)*
}



void EqualExpression() :
{
}
{
	RelationalExpression()
	(
	  ( <NE> RelationalExpression()
	    {
	    jjtThis.setFunction(tokenImage[NE]);
	    }
	  ) #FunNode(2)
	|
	  ( <NE2> RelationalExpression()
	    {
	    jjtThis.setFunction(tokenImage[NE2]);
	    }
	  ) #FunNode(2)
	|  
	  ( <EQ> RelationalExpression()
	    {
	      jjtThis.setFunction(tokenImage[EQ]);
	    }
	  ) #FunNode(2)
	)*
}



void RelationalExpression() :
{
}
{
  PostfixExpression()
  (
    ( <LT> PostfixExpression()
      {
	    jjtThis.setFunction(tokenImage[LT]);
      }
	) #FunNode(2)
	|
    ( <GT> PostfixExpression()
      {
        jjtThis.setFunction(tokenImage[GT]);
      }
    ) #FunNode(2)
    |
    ( <LE> PostfixExpression()
      {
	    jjtThis.setFunction(tokenImage[LE]);
      }
	) #FunNode(2)
	|
    ( <GE> PostfixExpression()
      {
        jjtThis.setFunction(tokenImage[GE]);
      }
    ) #FunNode(2)
  )*
}


void PostfixExpression() :
{
}
{
	AdditiveExpression()
	[
	  ( <IS_NOT_NULL> 
		{
		  jjtThis.setFunction(tokenImage[IS_NOT_NULL]);
		}
	  ) #FunNode(1)
	|
	  ( <IS_NULL>
		{
		  jjtThis.setFunction(tokenImage[IS_NULL]);
		}
	  ) #FunNode(1)
	|
	  ( <IN> Array()
		{
		  jjtThis.setFunction(tokenImage[IN]);
		}
	  ) #FunNode(2)
	|
	  ( <NOT_IN> Array()
		{
		  jjtThis.setFunction(tokenImage[NOT_IN]);
		}
	  ) #FunNode(2)	  
	|
	  ( <BETWEEN> AdditiveExpression() <AND> AdditiveExpression()
		{
		  jjtThis.setFunction(tokenImage[BETWEEN]);
		}
	  ) #FunNode(3)
	|
	  ( <LIKE> AdditiveExpression()
		{
		  jjtThis.setFunction(tokenImage[LIKE]);
		}
	  ) #FunNode(2)
	|
	  ( <NOT_LIKE> AdditiveExpression()
		{
		  jjtThis.setFunction(tokenImage[NOT_LIKE]);
		}
	  ) #FunNode(2)
  ]
}


void AdditiveExpression() :
{
}
{
  MultiplicativeExpression()
  (
    ( <CONCAT> MultiplicativeExpression()
      {
        jjtThis.setFunction(tokenImage[CONCAT]);
      }
    ) #FunNode(2)
    |
    ( <PLUS> MultiplicativeExpression()
      {
        jjtThis.setFunction(tokenImage[PLUS]);
      }
    ) #FunNode(2)
    |
    ( <MINUS> MultiplicativeExpression()
      {
        jjtThis.setFunction(tokenImage[MINUS]);
      }
    ) #FunNode(2)
  )*
}


void MultiplicativeExpression() :
{
}
{
  UnaryExpression()
  (
    ( <MUL> UnaryExpression()
      {
        jjtThis.setFunction(tokenImage[MUL]);
      }
    ) #FunNode(2)
	|
    ( <DIV> UnaryExpression()
      {
        jjtThis.setFunction(tokenImage[DIV]);
      }
    ) #FunNode(2)
	|
    ( <DIV2> UnaryExpression()
      {
        jjtThis.setFunction(tokenImage[DIV2]);
      }
    ) #FunNode(2)
	|
    ( <MOD> UnaryExpression()
      {
        jjtThis.setFunction(tokenImage[MOD]);
      }
    ) #FunNode(2)
  )*
}


void UnaryExpression() :
{
}
{
  ( <PLUS> UnaryExpression())
|
  ( <MINUS> UnaryExpression()
    {
	  jjtThis.setFunction(tokenImage[MINUS]);
    }
  ) #FunNode(1)
|
  ( <NOT> UnaryExpression()
    {
	  jjtThis.setFunction(tokenImage[NOT]);
    }
  ) #FunNode(1)
|
  UnaryExpressionNotPlusMinus()
}

void UnaryExpressionNotPlusMinus() :
{
	String identString = "";
	int type;
}
{
	AnyConstant()
|
    Variable()
|
	"(" Expression() ")"
}


void Variable() :
{
	String identString = "";
}
{
	(identString = Identifier()
	{
		jjtThis.setValue(identString);
	}
	) #VarNode
}

String Identifier() :
{
  Token t;
}
{
	t=<IDENTIFIER>
	{
		return t.image;
	}
}


void Array() #Array:
{
}
{
	"("
	AdditiveExpression()
	(
		","
		AdditiveExpression()
	)* 
	")"
}

void AnyConstant() #Constant:
{
	Token t;
}
{
	t=<NULL_LITERAL> {
		jjtThis.setValue(null);
	}
	|
	t=<TRUE_LITERAL> {
		jjtThis.setValue(Boolean.TRUE);
	}
	|
	t=<FALSE_LITERAL> {
		jjtThis.setValue(Boolean.FALSE);
	}
	|
	t=<STRING_LITERAL> {
		// strip away double quotes at end of string
		String temp = (t.image).substring(1,t.image.length()-1);
		// replace escape characters
		temp = replaceEscape(temp);
		jjtThis.setValue(temp);
	}
	|
	t=<INTEGER_LITERAL> {
		try {
			jjtThis.setValue(Integer.valueOf(t.image));
		} 
		catch (Exception e) {
			jjtThis.setValue(null);
			addToErrorList("Can't parse \"" + t.image + "\"");
		}
	}
	|
	t=<FLOATING_POINT_LITERAL> {
		try {
			jjtThis.setValue(new BigDecimal(t.image));
		} 
		catch (Exception e) {
			jjtThis.setValue(null);
			addToErrorList("Can't parse \"" + t.image + "\"");
		}
	}
}

